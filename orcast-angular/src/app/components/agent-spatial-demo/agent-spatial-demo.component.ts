import { Component, OnInit, OnDestroy, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Subscription } from 'rxjs';

import { AgentOrchestratorService, AgentMessage, SpatialForecast } from '../../services/agent-orchestrator.service';
import { MapConfigurationService, MapConfiguration, MapConfigRequest } from '../../services/map-configuration.service';

@Component({
  selector: 'orcast-agent-spatial-demo',
  standalone: true,
  imports: [CommonModule, FormsModule],
  template: `
    <div class="agent-spatial-demo">
      <!-- Header -->
      <div class="header">
        <h1>ORCAST Agent-Driven Spatial Planning</h1>
        <p class="subtitle">Multi-Agent Orchestration for Whale Research & Trip Planning</p>
        
        <div class="demo-controls">
          <button 
            (click)="startAgentDemo()" 
            [disabled]="isRunning"
            class="start-btn">
            ü§ñ Start Agent Orchestration
          </button>
          <button 
            (click)="generateMapConfig()" 
            [disabled]="isRunning"
            class="map-btn">
            üó∫Ô∏è Generate Map Configuration
          </button>
          <button 
            (click)="clearLogs()"
            class="clear-btn">
            üßπ Clear Logs
          </button>
        </div>
      </div>

      <div class="main-content">
        <!-- Left Panel: Agent Communication -->
        <div class="agent-panel">
          <div class="panel-header">
            <h3>ü§ñ Agent Communication Log</h3>
            <div class="agent-status">
              <span [class.active]="isRunning">
                {{isRunning ? 'Agents Active' : 'Ready'}}
              </span>
            </div>
          </div>
          
          <div class="agent-messages" #messagesContainer>
            <div 
              *ngFor="let message of agentMessages; trackBy: trackMessage"
              class="message"
              [class]="'message-' + message.type">
              
              <div class="message-header">
                <span class="agent-name">{{message.agent}}</span>
                <span class="timestamp">{{message.timestamp | date:'HH:mm:ss.SSS'}}</span>
              </div>
              
              <div class="message-content">{{message.message}}</div>
              
              <div class="message-data" *ngIf="message.data">
                <details>
                  <summary>Data Details</summary>
                  <pre>{{message.data | json}}</pre>
                </details>
              </div>
              
              <div class="data-source-info" *ngIf="message.data?.dataSourcesUsed">
                <h5>üìä Data Sources Used:</h5>
                <ul>
                  <li *ngFor="let source of message.data.dataSourcesUsed">
                    ‚úÖ {{source}}
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <!-- Center: Map Configuration Display -->
        <div class="map-config-panel">
          <div class="panel-header">
            <h3>üó∫Ô∏è Agent-Generated Map Configuration</h3>
            <div class="config-status">
              <span *ngIf="currentMapConfig">
                Generated by: {{currentMapConfig.generatedBy.agent}}
              </span>
            </div>
          </div>
          
          <div class="map-display" #mapContainer>
            <!-- Map will be rendered here -->
            <div id="agent-map" class="map-canvas"></div>
            
            <!-- Configuration Overlay -->
            <div class="config-overlay" *ngIf="currentMapConfig">
              <div class="overlay-info">
                <h4>üéØ Forecast Overview</h4>
                <p>{{currentMapConfig.UIStates.agentInterface.forecastOverview}}</p>
                
                <h4>‚è∞ Interactive Timeline</h4>
                <div class="timeline-controls">
                  <button 
                    *ngFor="let slice of currentMapConfig.UIStates.temporalSlider.timeSlices; let i = index"
                    (click)="selectTimeSlice(i)"
                    [class.active]="selectedTimeSlice === i"
                    class="time-slice-btn">
                    {{slice.label}}
                  </button>
                </div>
                
                <h4>üéõÔ∏è Layer Controls</h4>
                <div class="layer-controls">
                  <div 
                    *ngFor="let overlay of currentMapConfig.overlays"
                    class="layer-control">
                    <label>
                      <input 
                        type="checkbox" 
                        [checked]="overlay.visible"
                        (change)="toggleLayer(overlay.id, $event)">
                      {{overlay.id | titlecase}}
                    </label>
                    <div class="source-info">
                      üìä Source: {{overlay.source.name}}
                      ({{(overlay.source.confidenceLevel * 100).toFixed(1)}}% confidence)
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Right Panel: Spatial Forecasts -->
        <div class="forecast-panel">
          <div class="panel-header">
            <h3>üéØ Spatial Forecasts</h3>
            <div class="forecast-count">
              {{spatialForecasts.length}} predictions
            </div>
          </div>
          
          <div class="forecast-list">
            <div 
              *ngFor="let forecast of spatialForecasts.slice(-10); trackBy: trackForecast"
              class="forecast-item"
              [class]="'model-' + forecast.model">
              
              <div class="forecast-header">
                <span class="behavior">{{forecast.behavior | titlecase}}</span>
                <span class="probability">{{(forecast.probability * 100).toFixed(1)}}%</span>
              </div>
              
              <div class="forecast-details">
                <div class="location">
                  üìç {{forecast.location.lat.toFixed(4)}}, {{forecast.location.lng.toFixed(4)}}
                </div>
                <div class="model-info">
                  ü§ñ Model: {{forecast.model.toUpperCase()}}
                  ({{(forecast.confidence * 100).toFixed(1)}}% confidence)
                </div>
                <div class="timestamp">
                  ‚è∞ {{forecast.timestamp | date:'HH:mm:ss'}}
                </div>
              </div>
            </div>
          </div>
          
          <div class="data-source-verification">
            <h4>üîç Data Source Verification</h4>
            <div *ngIf="currentMapConfig" class="source-list">
              <div 
                *ngFor="let source of currentMapConfig.dataSources"
                class="source-item">
                <div class="source-name">{{source.name}}</div>
                <div class="source-details">
                  <span class="provider">{{source.provider}}</span>
                  <span class="verified" [class.yes]="source.verified">
                    {{source.verified ? '‚úÖ Verified' : '‚ùå Unverified'}}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .agent-spatial-demo {
      height: 100vh;
      background: linear-gradient(135deg, #001122 0%, #001f3f 100%);
      color: white;
      font-family: 'Inter', sans-serif;
      display: flex;
      flex-direction: column;
    }

    .header {
      padding: 20px 30px;
      background: rgba(0, 30, 60, 0.9);
      border-bottom: 2px solid #4fc3f7;
    }

    .header h1 {
      color: #4fc3f7;
      font-size: 2.2rem;
      margin: 0 0 5px 0;
    }

    .subtitle {
      color: #81d4fa;
      margin: 0 0 20px 0;
      font-size: 1.1rem;
    }

    .demo-controls {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .start-btn, .map-btn, .clear-btn {
      padding: 12px 24px;
      border: 2px solid #4fc3f7;
      background: rgba(79, 195, 247, 0.2);
      color: white;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    .start-btn:hover, .map-btn:hover {
      background: #4fc3f7;
      color: #001122;
    }

    .clear-btn:hover {
      background: #ff4444;
      border-color: #ff4444;
    }

    .start-btn:disabled, .map-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .main-content {
      flex: 1;
      display: grid;
      grid-template-columns: 400px 1fr 350px;
      gap: 0;
    }

    /* Agent Panel */
    .agent-panel {
      background: rgba(0, 30, 60, 0.8);
      border-right: 2px solid #4fc3f7;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 20px;
      border-bottom: 1px solid #4fc3f7;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-header h3 {
      margin: 0;
      color: #4fc3f7;
    }

    .agent-status span {
      padding: 5px 12px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      font-size: 0.9rem;
    }

    .agent-status span.active {
      background: rgba(76, 175, 80, 0.3);
      color: #4caf50;
    }

    .agent-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }

    .message {
      background: rgba(0, 0, 0, 0.3);
      margin-bottom: 12px;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #666;
      animation: slideIn 0.3s ease;
    }

    .message-processing { border-left-color: #ffeb3b; }
    .message-data { border-left-color: #2196f3; }
    .message-analysis { border-left-color: #9c27b0; }
    .message-prediction { border-left-color: #4caf50; }
    .message-coordination { border-left-color: #ff9800; }
    .message-reasoning { border-left-color: #e91e63; }
    .message-orchestration { border-left-color: #00bcd4; }

    .message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .agent-name {
      font-weight: 600;
      color: #4fc3f7;
    }

    .timestamp {
      font-size: 0.8rem;
      color: #666;
    }

    .message-content {
      color: #ccc;
      font-size: 0.95rem;
      line-height: 1.4;
      margin-bottom: 10px;
    }

    .message-data details {
      margin-top: 8px;
    }

    .message-data summary {
      cursor: pointer;
      color: #81d4fa;
      font-size: 0.9rem;
    }

    .message-data pre {
      font-size: 0.8rem;
      color: #81d4fa;
      margin: 8px 0 0 0;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }

    .data-source-info {
      margin-top: 10px;
      padding: 10px;
      background: rgba(76, 175, 80, 0.1);
      border-radius: 4px;
      border: 1px solid #4caf50;
    }

    .data-source-info h5 {
      margin: 0 0 8px 0;
      color: #4caf50;
      font-size: 0.9rem;
    }

    .data-source-info ul {
      margin: 0;
      padding-left: 20px;
    }

    .data-source-info li {
      color: #ccc;
      font-size: 0.85rem;
    }

    /* Map Config Panel */
    .map-config-panel {
      background: rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .config-status span {
      font-size: 0.9rem;
      color: #81d4fa;
    }

    .map-display {
      flex: 1;
      position: relative;
    }

    .map-canvas {
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, #001122, #004d40);
    }

    .config-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0, 30, 60, 0.95);
      border: 1px solid #4fc3f7;
      border-radius: 8px;
      padding: 20px;
      max-height: calc(100% - 40px);
      overflow-y: auto;
    }

    .overlay-info h4 {
      color: #4fc3f7;
      margin: 0 0 10px 0;
      font-size: 1rem;
    }

    .overlay-info p {
      color: #ccc;
      font-size: 0.9rem;
      line-height: 1.4;
      margin-bottom: 20px;
    }

    .timeline-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .time-slice-btn {
      padding: 6px 12px;
      background: rgba(79, 195, 247, 0.2);
      border: 1px solid #4fc3f7;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.2s ease;
    }

    .time-slice-btn.active {
      background: #4fc3f7;
      color: #001122;
    }

    .layer-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .layer-control label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #ccc;
      font-size: 0.9rem;
    }

    .source-info {
      font-size: 0.8rem;
      color: #81d4fa;
      margin-left: 24px;
      margin-top: 4px;
    }

    /* Forecast Panel */
    .forecast-panel {
      background: rgba(0, 30, 60, 0.8);
      border-left: 2px solid #4fc3f7;
      display: flex;
      flex-direction: column;
    }

    .forecast-count {
      background: rgba(79, 195, 247, 0.2);
      padding: 5px 10px;
      border-radius: 12px;
      font-size: 0.9rem;
      color: #81d4fa;
    }

    .forecast-list {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }

    .forecast-item {
      background: rgba(0, 0, 0, 0.3);
      margin-bottom: 12px;
      padding: 12px;
      border-radius: 6px;
      border-left: 4px solid #666;
    }

    .model-pinn { border-left-color: #4fc3f7; }
    .model-behavioral { border-left-color: #9c27b0; }
    .model-ensemble { border-left-color: #4caf50; }

    .forecast-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .behavior {
      font-weight: 600;
      color: #4fc3f7;
    }

    .probability {
      font-weight: 600;
      color: #4caf50;
    }

    .forecast-details {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .location, .model-info, .timestamp {
      font-size: 0.8rem;
      color: #ccc;
    }

    .data-source-verification {
      padding: 15px;
      border-top: 1px solid #4fc3f7;
    }

    .data-source-verification h4 {
      margin: 0 0 10px 0;
      color: #4fc3f7;
      font-size: 1rem;
    }

    .source-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .source-item {
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 4px;
    }

    .source-name {
      font-weight: 600;
      color: #81d4fa;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }

    .source-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .provider {
      font-size: 0.8rem;
      color: #ccc;
    }

    .verified {
      font-size: 0.8rem;
      padding: 2px 6px;
      border-radius: 3px;
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .verified.yes {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
    }

    @keyframes slideIn {
      from { transform: translateX(-20px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
  `]
})
export class AgentSpatialDemoComponent implements OnInit, OnDestroy {
  @ViewChild('messagesContainer') messagesContainer!: ElementRef;
  @ViewChild('mapContainer') mapContainer!: ElementRef;

  agentMessages: AgentMessage[] = [];
  spatialForecasts: SpatialForecast[] = [];
  currentMapConfig: MapConfiguration | null = null;
  selectedTimeSlice = 0;
  isRunning = false;

  private subscriptions: Subscription[] = [];

  constructor(
    private agentOrchestrator: AgentOrchestratorService,
    private mapConfigService: MapConfigurationService
  ) {}

  ngOnInit() {
    // Subscribe to agent messages
    this.subscriptions.push(
      this.agentOrchestrator.agentMessages$.subscribe(messages => {
        this.agentMessages = messages;
        this.scrollToLatestMessage();
      })
    );

    // Subscribe to spatial forecasts
    this.subscriptions.push(
      this.agentOrchestrator.spatialForecasts$.subscribe(forecasts => {
        this.spatialForecasts = forecasts;
      })
    );

    // Subscribe to map configurations
    this.subscriptions.push(
      this.mapConfigService.mapConfig$.subscribe(config => {
        this.currentMapConfig = config;
        if (config) {
          this.initializeMap(config);
        }
      })
    );

    console.log('ü§ñ Agent Spatial Demo Component initialized');
  }

  ngOnDestroy() {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }

  async startAgentDemo() {
    this.isRunning = true;
    
    try {
      console.log('üöÄ Starting agent-driven spatial planning demo...');
      
      // Clear previous messages
      this.agentOrchestrator.clearAgentMessages();
      
      // Start orchestration
      const session = await this.agentOrchestrator.orchestrateTripPlanning(
        "Plan a 2-day whale watching trip in the San Juan Islands with high probability viewing locations"
      );
      
      // Generate spatial forecasts for the planned locations
      if (session.tripPlan?.locations) {
        const coordinates = session.tripPlan.locations.map((loc: any) => loc.coordinates);
        await this.agentOrchestrator.generateSpatialForecasts(coordinates);
      }
      
      console.log('‚úÖ Agent orchestration completed:', session);
      
    } catch (error) {
      console.error('‚ùå Agent demo failed:', error);
    } finally {
      this.isRunning = false;
    }
  }

  async generateMapConfig() {
    this.isRunning = true;
    
    try {
      const request: MapConfigRequest = {
        timeRange: {
          start: new Date(),
          end: new Date(Date.now() + 48 * 60 * 60 * 1000), // Next 48 hours
          intervals: 6
        },
        placeIds: [
          'san_juan_islands',
          'haro_strait', 
          'boundary_pass',
          'lime_kiln_point',
          'cattle_point'
        ],
        behaviorTypes: ['feeding', 'traveling', 'socializing'],
        confidenceThreshold: 0.7
      };

      const mapConfig = await this.mapConfigService.getMapConfig(request);
      console.log('üó∫Ô∏è Map configuration generated:', mapConfig);
      
    } catch (error) {
      console.error('‚ùå Map configuration failed:', error);
    } finally {
      this.isRunning = false;
    }
  }

  clearLogs() {
    this.agentOrchestrator.clearAgentMessages();
    this.agentMessages = [];
  }

  selectTimeSlice(index: number) {
    this.selectedTimeSlice = index;
    console.log('‚è∞ Selected time slice:', index);
    // Update map visualization for selected time slice
  }

  toggleLayer(layerId: string, event: Event) {
    const target = event.target as HTMLInputElement;
    console.log(`üéõÔ∏è Toggle layer ${layerId}:`, target.checked);
    // Update map layer visibility
  }

  trackMessage(index: number, message: AgentMessage): string {
    return message.id;
  }

  trackForecast(index: number, forecast: SpatialForecast): string {
    return `${forecast.location.lat}-${forecast.location.lng}-${forecast.behavior}-${forecast.model}`;
  }

  private scrollToLatestMessage() {
    setTimeout(() => {
      if (this.messagesContainer) {
        const element = this.messagesContainer.nativeElement;
        element.scrollTop = element.scrollHeight;
      }
    }, 100);
  }

  private initializeMap(config: MapConfiguration) {
    console.log('üó∫Ô∏è Initializing map with configuration:', config);
    
    // Initialize Google Maps with the agent-generated configuration
    if (typeof google !== 'undefined' && google.maps && this.mapContainer) {
      const mapElement = this.mapContainer.nativeElement.querySelector('#agent-map');
      if (mapElement) {
        const map = new google.maps.Map(mapElement, config.mapOptions);
        
        // Add overlays from the configuration
        config.overlays.forEach(overlay => {
          if (overlay.visible) {
            this.addMapOverlay(map, overlay);
          }
        });
        
        console.log(`‚úÖ Map initialized with ${config.overlays.length} overlays`);
      }
    }
  }

  private addMapOverlay(map: google.maps.Map, overlay: any) {
    // Add overlay to map based on type
    console.log(`üìç Adding ${overlay.type} overlay: ${overlay.id}`);
    
    // Implementation would add actual overlay data to the map
    // This is a placeholder for the overlay rendering logic
  }
} 